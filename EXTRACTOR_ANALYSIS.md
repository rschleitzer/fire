# Search Parameter Extractor Analysis

## Current Status

The model files generated by `structs.scm` are **missing the search parameter extractors**, causing compilation errors:

```
error[E0432]: unresolved import `crate::models::patient::extract_patient_search_params`
error[E0432]: unresolved import `crate::models::practitioner::extract_practitioner_search_params`
error[E0432]: unresolved import `crate::models::observation::extract_observation_search_params`
```

## What Extractors Do

Extractors parse FHIR JSON resources and populate indexed search parameter columns for the database.

**Example flow:**
1. HTTP request: `POST /fhir/Patient` with JSON body
2. Repository calls: `extract_patient_search_params(&content)`
3. Extractor returns struct with extracted values
4. Repository inserts into database with populated search columns

## Extractor Structure

Each extractor consists of:

### 1. Search Params Struct

Mirrors the database columns defined in the migration:

```rust
#[derive(Debug, Default)]
pub struct PatientSearchParams {
    pub family_name: Vec<String>,
    pub given_name: Vec<String>,
    pub prefix: Vec<String>,
    pub suffix: Vec<String>,
    pub name_text: Vec<String>,
    pub identifier_system: Vec<String>,
    pub identifier_value: Vec<String>,
    pub birthdate: Option<NaiveDate>,
    pub gender: Option<String>,
    pub active: Option<bool>,
    pub general_practitioner_reference: Vec<String>,
}
```

### 2. Extraction Function

Navigates the FHIR JSON structure to extract values:

```rust
pub fn extract_patient_search_params(content: &Value) -> PatientSearchParams {
    let mut params = PatientSearchParams::default();

    // Extract names
    if let Some(names) = content.get("name").and_then(|n| n.as_array()) {
        for name in names {
            if let Some(family) = name.get("family").and_then(|f| f.as_str()) {
                params.family_name.push(family.to_string());
            }
            // ... more fields
        }
    }

    // Extract identifiers
    if let Some(identifiers) = content.get("identifier").and_then(|i| i.as_array()) {
        for identifier in identifiers {
            if let Some(system) = identifier.get("system").and_then(|s| s.as_str()) {
                params.identifier_system.push(system.to_string());
            }
            if let Some(value) = identifier.get("value").and_then(|v| v.as_str()) {
                params.identifier_value.push(value.to_string());
            }
        }
    }

    // ... more extractions

    params
}
```

## Patterns by Search Parameter Type

### String Parameters (`family`, `given`, etc.)

**Database columns:** `family_name TEXT[]`, `given_name TEXT[]`

**Extraction pattern:**
```rust
if let Some(names) = content.get("name").and_then(|n| n.as_array()) {
    for name in names {
        if let Some(family) = name.get("family").and_then(|f| f.as_str()) {
            params.family_name.push(family.to_string());
        }
    }
}
```

**Key features:**
- Navigate to nested object (`name`)
- Handle array of objects
- Extract string field
- Push to Vec in struct

### Token Parameters (`identifier`, `code`, `status`)

**Simple code (status):**

**Database columns:** `status TEXT`

```rust
if let Some(status) = content.get("status").and_then(|s| s.as_str()) {
    params.status = Some(status.to_string());
}
```

**Complex token (identifier, code):**

**Database columns:** `identifier_system TEXT[]`, `identifier_value TEXT[]`

```rust
if let Some(identifiers) = content.get("identifier").and_then(|i| i.as_array()) {
    for identifier in identifiers {
        if let Some(system) = identifier.get("system").and_then(|s| s.as_str()) {
            params.identifier_system.push(system.to_string());
        }
        if let Some(value) = identifier.get("value").and_then(|v| v.as_str()) {
            params.identifier_value.push(value.to_string());
        }
    }
}
```

**Key features:**
- For Identifier/Coding/CodeableConcept: extract both `system` and `value`/`code`
- Arrays stored in parallel Vec<String>
- Simple codes (like status) are single Option<String>

### Date Parameters (`birthdate`, `effective`)

**Simple date:**

**Database columns:** `birthdate DATE`

```rust
if let Some(birthdate) = content.get("birthDate").and_then(|b| b.as_str()) {
    if let Ok(date) = NaiveDate::parse_from_str(birthdate, "%Y-%m-%d") {
        params.birthdate = Some(date);
    }
}
```

**DateTime with variants (effective[x]):**

**Database columns:** `effective_datetime TIMESTAMPTZ`, `effective_period_start TIMESTAMPTZ`, `effective_period_end TIMESTAMPTZ`

```rust
// effectiveDateTime
if let Some(dt) = content.get("effectiveDateTime").and_then(|d| d.as_str()) {
    if let Ok(parsed) = DateTime::parse_from_rfc3339(dt) {
        params.effective_datetime = Some(parsed.with_timezone(&Utc));
    }
}

// effectivePeriod
if let Some(period) = content.get("effectivePeriod") {
    if let Some(start) = period.get("start").and_then(|s| s.as_str()) {
        if let Ok(parsed) = DateTime::parse_from_rfc3339(start) {
            params.effective_period_start = Some(parsed.with_timezone(&Utc));
        }
    }
    if let Some(end) = period.get("end").and_then(|e| e.as_str()) {
        if let Ok(parsed) = DateTime::parse_from_rfc3339(end) {
            params.effective_period_end = Some(parsed.with_timezone(&Utc));
        }
    }
}
```

**Key features:**
- Simple dates use `NaiveDate::parse_from_str`
- DateTimes use `DateTime::parse_from_rfc3339` and convert to UTC
- Period types extract `start` and `end`
- Choice types (`[x]`) check multiple JSON field names

### Reference Parameters (`subject`, `patient`, `encounter`)

**Database columns:** `subject_reference TEXT`, `patient_reference TEXT`

```rust
if let Some(subject) = content.get("subject") {
    if let Some(reference) = subject.get("reference").and_then(|r| r.as_str()) {
        params.subject_reference = Some(reference.to_string());
    }
}
```

**Collection of references:**

**Database columns:** `performer_reference TEXT[]`

```rust
if let Some(performers) = content.get("performer").and_then(|p| p.as_array()) {
    for performer in performers {
        if let Some(reference) = performer.get("reference").and_then(|r| r.as_str()) {
            params.performer_reference.push(reference.to_string());
        }
    }
}
```

**Key features:**
- Navigate to Reference object
- Extract `.reference` field (the actual reference string)
- Single references: Option<String>
- Multiple references: Vec<String>

### Quantity Parameters (`value-quantity`)

**Database columns:** `value_quantity_value NUMERIC(20,6)`, `value_quantity_unit TEXT`, `value_quantity_system TEXT`

```rust
if let Some(value_qty) = content.get("valueQuantity") {
    if let Some(value) = value_qty.get("value").and_then(|v| v.as_f64()) {
        params.value_quantity_value = Some(value);
    }
    if let Some(unit) = value_qty.get("unit").and_then(|u| u.as_str()) {
        params.value_quantity_unit = Some(unit.to_string());
    }
    if let Some(system) = value_qty.get("system").and_then(|s| s.as_str()) {
        params.value_quantity_system = Some(system.to_string());
    }
}
```

**Key features:**
- Extract three fields: value (f64), unit (String), system (String)
- Value uses `.as_f64()` for numeric extraction
- All three are Optional

### Boolean Parameters (`active`)

**Database columns:** `active BOOLEAN`

```rust
if let Some(active) = content.get("active").and_then(|a| a.as_bool()) {
    params.active = Some(active);
}
```

**Key features:**
- Use `.as_bool()` to extract boolean value
- Store as Option<bool>

## Generation Strategy

### Map XML Search Parameters to Extraction Code

**Input from XML model:**
```xml
<search name="family" type="string">
  <paths>
    <path>
      <parts>
        <part name="HumanName.family" ref="humannamefamily"/>
      </parts>
    </path>
  </paths>
</search>
```

**Generate:**
1. Struct field: `pub family_name: Vec<String>,`
2. Extraction code: Navigate to `name` (parent of path), iterate array, extract `family` field

### Key Challenges

1. **Path navigation** - Need to understand FHIR paths like `Patient.name.family`
2. **Choice types** - Handle `[x]` suffixes (e.g., `effective[x]` → `effectiveDateTime`, `effectivePeriod`)
3. **Type conversion** - Map FHIR types to Rust types (string → String, date → NaiveDate, dateTime → DateTime<Utc>)
4. **Collections** - Determine if field is 0..* (Vec) or 0..1 (Option)
5. **Nested structures** - Navigate through complex FHIR objects (Identifier, CodeableConcept, Period, Reference)

## Size Comparison

- **Patient extractor**: ~90 lines (12 search parameters)
- **Observation extractor**: ~190 lines (24 search parameters, more complex types)
- **Practitioner extractor**: ~140 lines (19 search parameters)

## Recommendation

Start with a **simple pattern-based generator**:

1. Generate struct from migration columns
2. For each search parameter, generate extraction based on type:
   - `string` → iterate array, extract field, push to Vec
   - `token` (simple) → extract single field
   - `token` (complex) → extract system + code/value
   - `date` → parse with appropriate parser
   - `reference` → navigate to Reference, extract .reference
   - `quantity` → extract value, unit, system
   - `boolean` → extract with .as_bool()

3. Use XML paths to determine JSON navigation
4. Handle choice types by checking variant names

This can be built incrementally, starting with the simplest patterns and adding complexity.
